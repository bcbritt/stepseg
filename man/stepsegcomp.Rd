% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stepseg.R
\name{stepsegcomp}
\alias{stepsegcomp}
\title{Stepwise Segmented Compositional Regression Analysis}
\usage{
stepsegcomp(
  dv,
  ivs = data.frame(1:nrow(data.frame(dv))),
  start_breakpoints = numeric(0),
  retain_start_breakpoints = TRUE,
  add = 0.15,
  remove = 0.2,
  bonferroni = TRUE,
  add_mode = "mse",
  ord = 1,
  type = "classical",
  allow_interactions = FALSE,
  update = 0,
  verbose = FALSE
)
}
\arguments{
\item{dv}{A data.frame representing values of the dependent variable}

\item{ivs}{A data.frame representing values of the independent variables,
coerced to a data.frame if not provided as one (default =
\code{data.frame(1:nrow(data.frame(dv)))}, which implicitly treats
\code{dv} as sequentially ordered data and attempts to detect breakpoints
in that sequence)}

\item{start_breakpoints}{A numeric vector of breakpoints to be added to the
regression model before the first iteration of the stepwise procedure}

\item{retain_start_breakpoints}{If \code{TRUE}, then the breakpoints
specified in \code{start_breakpoints} can never be removed from the model}

\item{add}{A numeric atomic vector between \code{0} and \code{1} indicating
the \emph{p}-value threshold to add coefficients to the model during each
forward selection iteration, which must be less than or equal to the
\code{remove} argument in order to avoid infinite loops (default =
\code{.15}, as recommended by Britt, 2015)}

\item{remove}{A numeric atomic vector between \code{0} and \code{1}
indicating the \emph{p}-value threshold to remove coefficients from the
model during each backward selection iteration, which must be greater than
or equal to the \code{add} argument in order to avoid infinite loops
(default = \code{.20}, as recommended by Britt, 2015)}

\item{bonferroni}{If \code{TRUE}, then the \emph{p}-values specified in
\code{add} and \code{remove} are divided by the number of terms added to
the model for each breakpoint, including all categories of the dependent
variable, all independent variables (including any interactions), and all
orders of those independent variables (\code{0:ord})}

\item{add_mode}{A character atomic vector (either \code{"p"} or \code{"mse"})
indicating what criterion should be used to select the best candidate
block during each forward selection iteration (default = \code{"mse"})}

\item{ord}{A non-negative numeric atomic vector indicating the maximum
exponent that will be applied to coefficients added to the regression
model (default = \code{1}; it is generally recommended to use either
\code{order = 0} or \code{order = 1})}

\item{type}{The method used to conduct compositional regression; since
\code{\link[Compositional]{comp.reg}} does not return standard errors for
\code{"lmfit"} or \code{"spatial"}, at present, this must be set to
\code{"classical"}}

\item{allow_interactions}{A boolean value indicating whether interactions
may be created between indicator functions representing breakpoints along
one independent variable with other independent variables in the model
(default = \code{FALSE}, which restricts each indicator function to only
interact with the independent variable along which its breakpoint was
defined)}

\item{update}{A numeric value indicating how many loop iterations should
elapse between progress updates (default = \code{0}, which suppresses
output)}

\item{verbose}{A boolean value indicating whether the current regression
model and results should be outputted as part of the progress report after
every step of the stepwise procedure (default = \code{FALSE}}
}
\value{
The final compositional regression model outputted from
\code{\link[Compositional]{comp.reg}}
}
\description{
This function performs stepwise segmented compositional
regression analysis, a modified form of the procedure described by Britt
(2015).
}
\details{
When using any form of stepwise segmented regression analysis,
coefficients are added to and removed from the model in "blocks," with a
given block consisting of the indicator function representing a given
breakpoint location as well as all interaction terms between that indicator
function and independent variables that are eligible to be added to the
model.

The \code{ord} and \code{allow_interactions} arguments jointly indicate what
interaction terms are valid. \code{ord} indicates the maximum exponent that
can be applied to the independent variables, while \code{allow_interactions}
indicates whether interaction terms can be created between a given
independent variable and an indicator function that is defined by values of a
different independent variable.

All interaction terms that are considered valid, with exponents ranging from
\code{0} to \code{ord}, are included in a given block. Consider, for
instance, an analysis in which \code{ivs}, the data.frame representing the
independent variables, has three columns signifying three variables. If
\code{ord = 1} and \code{allow_interactions = FALSE}, which are their default
values in \code{stepseg}, then the block corresponding to a potential
breakpoint at \code{ivs[, 1] = 10} would include two coefficients:
\itemize{
\item{\code{I(ivs[, 1] = 10)}}
\item{\code{I(ivs[, 1] = 10) * (ivs[, 1]^1)}}
}
Setting \code{ord = 2} would retain both of the aforementioned
coefficients and also add
\itemize{
\item{\code{I(ivs[, 1] = 10) * (ivs[, 1]^2)}}
}
to the block. Maintaining \code{ord = 2} and setting
\code{allow_interactions = TRUE} would result in the block containing a
total of seven coefficients:
\itemize{
\item{\code{ivs[, 1] = 10}}
\item{\code{I(ivs[, 1] = 10) * (ivs[, 1]^1)}}
\item{\code{I(ivs[, 1] = 10) * (ivs[, 1]^2)}}
\item{\code{I(ivs[, 1] = 10) * (ivs[, 2]^1)}}
\item{\code{I(ivs[, 1] = 10) * (ivs[, 2]^2)}}
\item{\code{I(ivs[, 1] = 10) * (ivs[, 3]^1)}}
\item{\code{I(ivs[, 1] = 10) * (ivs[, 3]^2)}}
}
Note that if \code{ord = 0}, then each block will only include the
indicator function itself (in this example, \code{I(ivs[, 1] = 10)})
regardless of the value of \code{allow_interactions}.

During each forward selection iteration, the algorithm selects the "best"
block of coefficients that can be added. If \code{add_mode = "p"}, then all
possible candidate blocks that could be added to the model are evaluated,
and whichever block has a \emph{p}-value less than or equal to all
\emph{p}-values in all other blocks is treated as the "best" block. As long
as that \emph{p}-value is less than the threshold specified by the
\code{add} argument, all coefficients included in the block are added to the
model. If \code{add_mode = "mse"}, then the candidate block whose
coefficients would jointly reduce the model mean squared error by the
greatest amount is treated as the \code{best} block, and all of its coefficients
are added to the model if the resulting \emph{p}-value for at least one of
those coefficients would be less than \code{add}.

During each backward selection iteration, all coefficients listed in
\code{start_formula} are retained in the regression model. Among all
remaining coefficients, any blocks whose \emph{p}-values are all greater
than or equal to \code{remove} are removed from the model. If at least one
\emph{p}-value contained in a given block is less than \code{remove}, then
none of the coefficients in the block are removed from the model.

When \code{ord = 0}, \code{add_mode = "p"} is generally acceptable to follow
common conventions of stepwise model selection. When \code{ord > 0}, however,
\code{add_mode = "p"} is more likely to result in spurious breakpoints being
added to the model due to intercept and higher-order terms competing with one
another, and in rare cases the algorithm may entirely fail to converge.
\code{add_mode = "mse"} is more robust against these issues and is generally
recommended as whenever \code{ord > 0}.

As a caveat, since compositional data are multidimensional in nature, there
may be rare cases in which the most suitable breakpoint selected based on MSE
does not correspond to a statistically significant change in any individual
category of the dependent variable. This can cause the model to prematurely
terminate. If an inspection of the final model suggests that such an issue
has occurred, then setting \code{add_mode = "p"} may allow that problem to be
overcome, regardless of other weaknesses in that option.

The larger the value of \code{ord}, the more likely spurious breakpoints are
to emerge. As with other regression contexts, you should only increase the
complexity of your model (such as by increasing the value of \code{ord}) when
you have a clear reason to do so. Moreover, whenever \code{ord > 0},
singularities may occur that render some coefficients inestimable. For
instance, if \code{ord = 3} and a pair of breakpoints is identified along the
same independent variable, with those two breakpoints occurring two data
points apart, there will be insufficient data between the breakpoints to
estimate the standard error of the interaction between the indicator function
and a cubic term, so it will be reported as \code{NA}. This is normal,
expected behavior in stepwise segmented regression analysis. In such cases,
those \code{NA} coefficients can be treated as though they were absent from
the model.

Finally, use caution when setting \code{ord > 1}, as increasingly high-order
terms may compete with lower-order terms in the model and yield unpredictable
results. Refer to Britt (2015) for more information.
}
\section{References}{

Britt, B. C. (2015). Stepwise segmented regression analysis: An iterative
statistical algorithm to detect and quantify evolutionary and
revolutionary transformations in longitudinal data. In S. A. Matei, M. G.
Russell, & E. Bertino (Eds.), \emph{Transparency in social media: Tools,
methods, and algorithms for mediating online interactions} (pp. 125-144).
Heidelberg, Germany: Springer.
}

\examples{
dv <- rbind(c(0.058, 0.050, 0.010, 0.221, 0.186, 0.068, 0.407),
            c(0.054, 0.065, 0.009, 0.262, 0.196, 0.069, 0.345),
            c(0.040, 0.114, 0.004, 0.235, 0.191, 0.084, 0.332),
            c(0.044, 0.070, 0.011, 0.356, 0.172, 0.049, 0.298),
            c(0.048, 0.123, 0.007, 0.277, 0.175, 0.053, 0.317),
            c(0.046, 0.101, 0.013, 0.240, 0.212, 0.105, 0.283),
            c(0.058, 0.125, 0.010, 0.257, 0.191, 0.050, 0.309),
            c(0.048, 0.065, 0.010, 0.264, 0.247, 0.083, 0.283),
            c(0.072, 0.067, 0.006, 0.237, 0.197, 0.097, 0.324),
            c(0.040, 0.192, 0.002, 0.243, 0.174, 0.069, 0.280),
            c(0.041, 0.175, 0.005, 0.208, 0.174, 0.075, 0.322),
            c(0.046, 0.098, 0.004, 0.274, 0.206, 0.058, 0.314),
            c(0.037, 0.087, 0.004, 0.237, 0.222, 0.092, 0.321),
            c(0.035, 0.084, 0.004, 0.287, 0.196, 0.067, 0.327),
            c(0.040, 0.061, 0.004, 0.271, 0.226, 0.059, 0.339),
            c(0.038, 0.239, 0.006, 0.228, 0.148, 0.052, 0.289),
            c(0.051, 0.141, 0.004, 0.243, 0.180, 0.068, 0.313),
            c(0.035, 0.156, 0.007, 0.227, 0.199, 0.063, 0.313),
            c(0.037, 0.188, 0.008, 0.258, 0.197, 0.048, 0.264),
            c(0.037, 0.126, 0.002, 0.309, 0.180, 0.032, 0.314),
            c(0.035, 0.092, 0.005, 0.237, 0.242, 0.059, 0.330),
            c(0.043, 0.114, 0.005, 0.225, 0.245, 0.057, 0.311),
            c(0.038, 0.139, 0.002, 0.270, 0.184, 0.053, 0.314),
            c(0.049, 0.080, 0.010, 0.243, 0.215, 0.068, 0.335),
            c(0.041, 0.081, 0.005, 0.219, 0.193, 0.053, 0.408),
            c(0.045, 0.115, 0.001, 0.266, 0.181, 0.052, 0.340),
            c(0.047, 0.140, 0.003, 0.253, 0.170, 0.066, 0.321),
            c(0.049, 0.226, 0.003, 0.239, 0.170, 0.047, 0.266),
            c(0.041, 0.119, 0.002, 0.358, 0.153, 0.035, 0.292),
            c(0.030, 0.165, 0.010, 0.391, 0.090, 0.030, 0.284))
ivs <- c(1:30)
model <- stepsegcomp(dv, ivs, verbose=TRUE)
# "Beginning the stepwise procedure..."
# "End of step 1 ~ Current Breakpoints: 23"
# "End of step 2 ~ Current Breakpoints: 4, 23"
# "No additional breakpoints can be added to the model."
model
# $runtime
#    user  system elapsed 
#       0       0       0 
#
# $be
#                                  [,1]        [,2]       [,3]        [,4]
# (Intercept)                -0.2878712 -1.96059047  1.0820294  1.12821655
# xivs[,1]^1                  0.2700093  0.06038650  0.2450410  0.08682669
# xI(ivs[,1]>4)*(ivs[,1]^0)   0.7953717  0.19964276  0.4145045  0.09793102
# xI(ivs[,1]>4)*(ivs[,1]^1)  -0.2344747 -0.08772856 -0.2252737 -0.06469739
# xI(ivs[,1]>23)*(ivs[,1]^0) -4.2608171 -1.32045504 -3.1891707  1.80206300
# xI(ivs[,1]>23)*(ivs[,1]^1)  0.1431590  0.05065426  0.1120019 -0.08473563
#                                   [,5]         [,6]
# (Intercept)                 0.22781059  1.919198434
# xivs[,1]^1                  0.03425128  0.015529618
# xI(ivs[,1]>4)*(ivs[,1]^0)   0.23577716 -0.241304627
# xI(ivs[,1]>4)*(ivs[,1]^1)  -0.03957347  0.005926647
# xI(ivs[,1]>23)*(ivs[,1]^0)  1.58830152  0.353969914
# xI(ivs[,1]>23)*(ivs[,1]^1) -0.06607795 -0.022286050
#
# $seb
#                                  [,1]      [,2]       [,3]       [,4]
# (Intercept)                0.50524000 0.7699158 0.24702365 0.22129975
# xivs[,1]^1                 0.18448756 0.2811335 0.09020028 0.08080724
# xI(ivs[,1]>4)*(ivs[,1]^0)  0.56810356 0.8657112 0.27775912 0.24883456
# xI(ivs[,1]>4)*(ivs[,1]^1)  0.18529495 0.2823639 0.09059504 0.08116089
# xI(ivs[,1]>23)*(ivs[,1]^0) 2.12661681 3.2406697 1.03975270 0.93147764
# xI(ivs[,1]>23)*(ivs[,1]^1) 0.07985208 0.1216835 0.03904155 0.03497594
#                                  [,5]       [,6]
# (Intercept)                0.32977623 0.21663586
# xivs[,1]^1                 0.12041725 0.07910423
# xI(ivs[,1]>4)*(ivs[,1]^0)  0.37080803 0.24359039
# xI(ivs[,1]>4)*(ivs[,1]^1)  0.12094425 0.07945042
# xI(ivs[,1]>23)*(ivs[,1]^0) 1.38806839 0.91184680
# xI(ivs[,1]>23)*(ivs[,1]^1) 0.05212042 0.03423883
#
# $est
# NULL
# 
# $t
#                                  [,1]       [,2]      [,3]       [,4]
# (Intercept)                -0.5697712 -2.5464998  4.380266  5.0981376
# xivs[,1]^1                  1.4635635  0.2147965  2.716632  1.0744914
# xI(ivs[,1]>4)*(ivs[,1]^0)   1.4000470  0.2306113  1.492316  0.3935588
# xI(ivs[,1]>4)*(ivs[,1]^1)  -1.2654136 -0.3106933 -2.486601 -0.7971499
# xI(ivs[,1]>23)*(ivs[,1]^0) -2.0035660 -0.4074636 -3.067240  1.9346283
# xI(ivs[,1]>23)*(ivs[,1]^1)  1.7928026  0.4162787  2.868788 -2.4226831
#                                  [,5]        [,6]
# (Intercept)                 0.6908036  8.85909836
# xivs[,1]^1                  0.2844383  0.19631842
# xI(ivs[,1]>4)*(ivs[,1]^0)   0.6358470 -0.99061637
# xI(ivs[,1]>4)*(ivs[,1]^1)  -0.3272042  0.07459553
# xI(ivs[,1]>23)*(ivs[,1]^0)  1.1442531  0.38819012
# xI(ivs[,1]>23)*(ivs[,1]^1) -1.2677940 -0.65089993
#
# $p
#                                  [,1]       [,2]         [,3]         [,4]
# (Intercept)                0.57412808 0.01771475 0.0002008412 3.242277e-05
# xivs[,1]^1                 0.15628846 0.83174067 0.0120382387 2.932869e-01
# xI(ivs[,1]>4)*(ivs[,1]^0)  0.17429429 0.81957130 0.1486457861 6.973815e-01
# xI(ivs[,1]>4)*(ivs[,1]^1)  0.21787098 0.75871609 0.0202485998 4.331800e-01
# xI(ivs[,1]>23)*(ivs[,1]^0) 0.05653118 0.68727920 0.0052865773 6.490810e-02
# xI(ivs[,1]>23)*(ivs[,1]^1) 0.08561900 0.68090526 0.0084573677 2.332019e-02
#                                 [,5]         [,6]
# (Intercept)                0.4963166 4.953975e-09
# xivs[,1]^1                 0.7785143 8.460138e-01
# xI(ivs[,1]>4)*(ivs[,1]^0)  0.5308933 3.317559e-01
# xI(ivs[,1]>4)*(ivs[,1]^1)  0.7463503 9.411548e-01
# xI(ivs[,1]>23)*(ivs[,1]^0) 0.2638031 7.012974e-01
# xI(ivs[,1]>23)*(ivs[,1]^1) 0.2170338 5.212948e-01
}
